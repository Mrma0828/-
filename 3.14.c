#include <stdio.h>
//数据存储学习(就是数据在内存中的存储方式不同)
// 数据类型
// 1.整形存储  
// 2.浮点存储
// 
//test 1 整数类型的存储（原码 反码（符号位不变 各位取反） 补码（反码加1））
//对于整数来说 无非分为两种类型 有符号（内存中放补码） 无符号（原反补一致）
//int main()
//{
//	signed int a = 10;
//	//在内存中查到 0a 00 00 00
//	//因为 正数原 反 补 一致  所以原码也为 0a 00 00 00 
//	//所以16进制转10进制 为10
//	int b = -10;
//	//在内存中查到补码为f6 ff ff ff 1111 1111 1111 1111 1111 1111 1111 0110 
//	//反码为1111 1111 1111 1111 1111 1111 1111 0101
//	//原码为1000 0000 0000 0000 0000 0000 0000 1010
//	//2进制转化为10进制即为-10
//	return 0;
//
//}
////test 2 整数加法（即对补码相加）
//int main()
//{
//	
//	1 - 1;
//	//1 + (-1)
//	//000000000000000000000001
//	//100000000000000000000001 --111111111111111111111110---1111111111111111111111
//	//1000000000000000000000000
//	//加过后为33为 10000000000000000 1溢出了内存 剩下0000000000000000000000000000
//
//}
//test 3 查询机器的字节序
//int main()
//{
//	int a = 1;//将0x00000001放入内存
//	char* p = (char*) &a;//将a的地址给p 以便可以用p找到a
//	//大端存储  即低位数据放在高位内存
//	//小端存储  即低位数据放在低位内存
//	if (*p == 1)
//	{
//		printf("电脑为小端存储");//指针类型决定解引用的字节大小 char为1个字节 如果01
//
//	}
//	else
//	{
//		printf("电脑为大端存储");//如果为低位为00
//	}
//	return 0;
//}

//test 4 数据的存储与取出（整形提升）
//有符号 补1   无符号 补0
//int main()
//{
//	char a = -1;
//	//整形-1为
//	//1000000000000000000000000000000001
//	//1111111111111111111111111111111110
//	//1111111111111111111111111111111111
//	//存入char1字节的内存
//	//1111111111
//
//	//以%d的形式取出(将 a 从char提升为 int 补的位置为符号位补    若为无符号补0   然后以有符号数字取出）
//	//1111111111111111111111111111111111--1111111111111111111110---10000000000000000000001
//
//
//
//
//	signed char b = -1;
//
//
//
//
//	unsigned char c = -1;
//	//11111111
//	//整形提升 补符号位 0000000000000000000000111111111（原 反 补相同）
//	//则输出255
//	printf("a = %d ,b = %d,c = %d", a, b, c);//%d
//	return 0;
//}

//test 5浮点数的存储

int main()
{
	float f = 5.5;
	//5.5在内存中为 101.1
	//s为符号位 （-1)^s  m为科学计数法的有效数字 e为数量级 (分别占1 23  8 个字节) m不用存1以提升精准级别 e加127
	//所以101.1为  （-1）^ 0 * 1.011 * 10 ^2
	//s = 0   e = 2 +127  m = 1.011 
	//所以存在内存中为 0 100000001  01100000000000000000000
	//0x40b00000

	//特殊情况 1. 当e为全0时 e为1-127  有效数字不在加一 为0.xxxxxx
	//2.e为全1时 有效数字m全为0  表示无穷大


	return 0;
}